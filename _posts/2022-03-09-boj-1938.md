---
layout: single
title:  "BOJ_1938_í†µë‚˜ë¬´ ì˜®ê¸°ê¸°"
categories: BOJ
tags: [BFS,ì‹œë®¬ë ˆì´ì…˜,Gold2]
toc: true
author_profile: false
sidebar:
    nav: "docs"
search: false
---

<br>

# âœ”ï¸ Problem

[í†µë‚˜ë¬´ ì˜®ê¸°ê¸°](https://www.acmicpc.net/problem/1938)

<br>

### ğŸ’¡ í’€ì´ ê³¼ì •

******************************************************************

BFS ë¬¸ì œ

í†µë‚˜ë¬´ë¥¼ ëª©ì ì§€ê¹Œì§€ ë„£ëŠ” ë¬¸ì œ<br><br>



##### â–ª í†µë‚˜ë¬´ ë§Œë“¤ê¸°

<br>ì…ë ¥ë°›ì€ í†µë‚˜ë¬´ ì •ë³´ë¥¼ ë°”íƒ•ìœ¼ë¡œ í†µë‚˜ë¬´ ëª¨ì–‘ì„ êµ¬ì„±í•˜ê¸° ìœ„í•œ í´ë˜ìŠ¤

implements comparableì„ í•˜ì—¬  ì •ë ¬ ì‹œ í†µë‚˜ë¬´ê°€ êµ¬ì„±ë˜ë„ë¡ êµ¬í˜„

```java
//ì¢Œí‘œ í´ë˜ìŠ¤ implements comparable
	static class CO implements Comparable<CO> {
		int x, y, flag,distance;
		public CO(int x, int y, int flag, int distance) {
			super();
			this.x = x;
			this.y = y;
			this.flag = flag; //í†µë‚˜ë¬´ ëª¨ì–‘
			this.distance = distance;
		}

		//x ì¢Œí‘œê°€ ê°™ë‹¤ë©´ ã…£í˜• í†µë‚˜ë¬´ (flag 1)
		//y ì¢Œí‘œê°€ ê°™ë‹¤ë©´ ã…¡í˜• í†µë‚˜ë¬´ (flag 2)
		@Override
		public int compareTo(CO o) {
			if (this.x == o.x) {
				flag = 1;
				return this.y - o.y;
			}
			flag = 2;
			return this.x - o.x;
		}
	}
```

[ã…£ í˜•]

xì¢Œí‘œê°€ ê°™ë‹¤ëŠ” ê²ƒì€ l í˜• ëª¨ì–‘,    yì¢Œí‘œ ìˆœìœ¼ë¡œ ì •ë ¬í•œ í›„ flag=1



[ã…¡ í˜•]

yì¢Œí‘œê°€ ê°™ë‹¤ëŠ” ê²ƒì€ ã…¡í˜• ëª¨ì–‘,    xì¢Œí‘œ ìˆœìœ¼ë¡œ ì •ë ¬í•œ í›„ flag=2

<br>

##### â–ª BFS

ìƒ, í•˜, ì¢Œ, ìš°, íšŒì „ check

<span style="color:#2d3748;background-color:#fff5b1">ì²« ë²ˆì§¸</span>,  í†µë‚˜ë¬´ ëª¨ì–‘ì— ë”°ë¥¸ ì¸ì ‘ ë°©í–¥ì„ ì²´í¬í•œë‹¤	<span style ="background-color:#f1f8ff">[ l í˜•  :  ì¢Œ,ìš° check]</span>, <span style ="background-color:#f1f8ff">[ ã…¡í˜•  :  ìƒ,í•˜ check]</span>

``` java
//ì„¸ë¡œì¼ ë•Œ ì¡°ê±´
if (cur.flag == 1) {
	if(nx<0||nx>=N||ny<1||ny>=N-1) continue;
					
	if ((d == 2 || d == 3)) {
	if (map[ny][nx] != 0 || map[ny + 1][nx] != 0 || map[ny - 1][nx] != 0) continue;
		cnt1++;
	}
	if (d == 0 && map[ny - 1][nx] != 0) continue;
	if (d == 1 && map[ny + 1][nx] != 0) continue;
}

//ê°€ë¡œì¼ ë•Œ ì¡°ê±´
else if (cur.flag == 2) {
	if(ny<0||ny>=N||nx<1||nx>=N-1) continue;
					
	if (d == 0 || d == 1) {
		if (map[ny][nx] != 0 || map[ny][nx + 1] != 0 || map[ny][nx - 1] != 0) continue;
		cnt2++;
	}
	if (d == 2 && map[ny][nx - 1] != 0) continue;
	if (d == 3 && map[ny][nx + 1] != 0) continue;
}
```

<br><span style="color:#2d3748;background-color:#fff5b1">ë‘ ë²ˆì§¸</span>,  ì¸ì ‘ ë°©í–¥ì— ì¥ì• ë¬¼ì´ ì—†ê³  ì´ë™ì´ ê°€ëŠ¥í•˜ë©´ queueì— ë“±ë¡ & cnt ì¦ê°€

```java
if (!visit[cur.flag][ny][nx]) {		
	queue.offer(new CO(nx, ny, cur.flag,cur.distance+1));
	visit[cur.flag][ny][nx] = true;
}
```

<br><span style="color:#2d3748;background-color:#fff5b1">ì„¸ ë²ˆì§¸</span>,  cnt=2 : ì¸ì ‘ ë°©í–¥ ëª¨ë‘ ì¥ì• ë¬¼ì´ ì—†ë‹¤ -> íšŒì „ queueì— ë“±ë¡ 

```java
//íšŒì „ ê°€ëŠ¥í•˜ë©´ íšŒì „ ì¼€ì´ìŠ¤ queueì— ì¶”ê°€ (ì–‘ìª½ ë‘˜ë‹¤ ë¹„ì—ˆìœ¼ë©´(cnt=2)) 
if (!visit[2][cur.y][cur.x] && cnt1 == 2)
	queue.offer(new CO(cur.x, cur.y, 2,cur.distance+1));
if (!visit[1][cur.y][cur.x] && cnt2 == 2)
	queue.offer(new CO(cur.x, cur.y, 1,cur.distance+1));
```

<br><span style="color:#2d3748;background-color:#fff5b1">ë§ˆì§€ë§‰</span>,   ëª©ì ì§€ì— ë„ì°©í•˜ë©´ ìµœì†Œ ë™ì‘ íšŸìˆ˜ ì¶œë ¥ í›„ return;

```java
//ëª©ì ì§€ì— ë„ë‹¬í•˜ë©´ ìµœì†Œë™ì‘íšŸìˆ˜ ì¶œë ¥ í›„ ì¢…ë£Œ
if (cur.x == goal[1].x && cur.y == goal[1].y && cur.flag == goal[1].flag) {
	System.out.println(cur.distance);
	return;
}
```

<br>

<br>

##### â–ª ê²°ê³¼

![image-20220309231944669](../images/2022-03-09-boj-1938/image-20220309231944669.png)

<br>				

### ğŸ“ƒ ì½”ë“œ(java 8)

```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.Arrays;
import java.util.LinkedList;
import java.util.Queue;

public class Main {
	static int N;
	static int map[][];

	// ìƒí•˜ì¢Œìš°
	static int dx[] = { 0, 0, -1, 1 };
	static int dy[] = { -1, 1, 0, 0 };
	
	//ì¢Œí‘œ í´ë˜ìŠ¤ implements comparable
	static class CO implements Comparable<CO> {
		int x, y, flag,distance;
		public CO(int x, int y, int flag, int distance) {
			super();
			this.x = x;
			this.y = y;
			this.flag = flag;
			this.distance = distance;
		}

		//x ì¢Œí‘œê°€ ê°™ë‹¤ë©´ ã…£í˜• í†µë‚˜ë¬´ (flag 1)
		//y ì¢Œí‘œê°€ ê°™ë‹¤ë©´ ã…¡í˜• í†µë‚˜ë¬´ (flag 2)
		@Override
		public int compareTo(CO o) {
			if (this.x == o.x) {
				flag = 1;
				return this.y - o.y;
			}
			flag = 2;
			return this.x - o.x;
		}
	}

	static CO[] goal = new CO[3]; //ëª©ì ì§€
	static CO[] tong = new CO[3]; //í†µë‚˜ë¬´

	public static void main(String[] args) throws NumberFormatException, IOException {
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		N = Integer.parseInt(br.readLine());
		map = new int[N][N];

		int tong_cnt = 0;
		int goal_cnt = 0;
		
		//ì§€ë„ ì…ë ¥
		for (int i = 0; i < N; i++) {
			String str = br.readLine();
			for (int j = 0; j < N; j++) {
				char temp = str.charAt(j);
				if (temp == 'B') {
					tong[tong_cnt++] = new CO(j, i, 0,0);
					map[i][j] = 0;
				} else if (temp == 'E') {
					goal[goal_cnt++] = new CO(j, i, 0,0);
					map[i][j] = 0;
				} else
					map[i][j] = temp - '0';
			}
		}
		
		//í†µë‚˜ë¬´,ëª©ì ì§€ ì •ë ¬
		Arrays.sort(goal);
		Arrays.sort(tong);

		bfs();

	}

	//bfs
	static void bfs() {
		boolean visit[][][] = new boolean[3][N][N];//ë°©í–¥,yì¢Œí‘œ,xì¢Œí‘œ
		Queue<CO> queue = new LinkedList<>();
		queue.offer(tong[1]);
		visit[tong[1].flag][tong[1].y][tong[1].x] = true;

		while (!queue.isEmpty()) {
			CO cur = queue.poll();
			
			//ëª©ì ì§€ì— ë„ë‹¬í•˜ë©´ ìµœì†Œë™ì‘íšŸìˆ˜ ì¶œë ¥ í›„ ì¢…ë£Œ
			if (cur.x == goal[1].x && cur.y == goal[1].y && cur.flag == goal[1].flag) {
				System.out.println(cur.distance);
				return;
			}
			
			//íšŒì „ ê°€ëŠ¥í•œì§€ ì²´í¬ íšŸìˆ˜ (2ê°€ ë˜ë©´ íšŒì „ ê°€ëŠ¥)
			int cnt1 = 0; //ì„¸ë¡œ ê¸°ì¤€ ->ì™¼ìª½ì´ ë¹„ë©´ ++, ì˜¤ë¥¸ìª½ì´ ë¹„ë©´ ++ / ë‘˜ë‹¤ ë¹„ë©´ 2ê°€ ë¨
			int cnt2 = 0;
			
			for (int d = 0; d < 4; d++) {
				int nx = cur.x + dx[d];
				int ny = cur.y + dy[d];
			
				//ì„¸ë¡œì¼ ë•Œ ì¡°ê±´
				if (cur.flag == 1) {
					if(nx<0||nx>=N||ny<1||ny>=N-1) continue;
					
					if ((d == 2 || d == 3)) {
						if (map[ny][nx] != 0 || map[ny + 1][nx] != 0 || map[ny - 1][nx] != 0) continue;
						cnt1++;
					}
					if (d == 0 && map[ny - 1][nx] != 0) continue;
					if (d == 1 && map[ny + 1][nx] != 0) continue;
				}

				//ê°€ë¡œì¼ ë•Œ ì¡°ê±´
				else if (cur.flag == 2) {
					if(ny<0||ny>=N||nx<1||nx>=N-1) continue;
					
					if (d == 0 || d == 1) {
						if (map[ny][nx] != 0 || map[ny][nx + 1] != 0 || map[ny][nx - 1] != 0) continue;
						cnt2++;
					}
					if (d == 2 && map[ny][nx - 1] != 0) continue;
					if (d == 3 && map[ny][nx + 1] != 0) continue;
				}

				//ë°©ë¬¸í•˜ì§€ ì•Šì•˜ë‹¤ë©´ ë‹¤ìŒ ëª©ì ì§€ë¡œ ë“±ë¡ 
				if (!visit[cur.flag][ny][nx]) {		
					queue.offer(new CO(nx, ny, cur.flag,cur.distance+1));
					visit[cur.flag][ny][nx] = true;
				}
				
			}

			//íšŒì „ ê°€ëŠ¥í•˜ë©´ íšŒì „ ì¼€ì´ìŠ¤ queueì— ì¶”ê°€ (ì–‘ìª½ ë‘˜ë‹¤ ë¹„ì—ˆìœ¼ë©´(cnt=2)) 
			if (!visit[2][cur.y][cur.x] && cnt1 == 2)
				queue.offer(new CO(cur.x, cur.y, 2,cur.distance+1));
			if (!visit[1][cur.y][cur.x] && cnt2 == 2)
				queue.offer(new CO(cur.x, cur.y, 1,cur.distance+1));
		}
		
		System.out.println(0);
	}

}
```

