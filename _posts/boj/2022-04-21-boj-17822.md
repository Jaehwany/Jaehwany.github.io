---
layout: single
title:  "[ë°±ì¤€] 17822ë²ˆ ì›íŒ ëŒë¦¬ê¸°"
categories: BOJ
tags: [BFS, Gold]
toc: true
toc_sticky: true
author_profile: false
sidebar:
    nav: "docs"
search: false
---

<br>

# âœ”ï¸ Problem  : [ì›íŒ ëŒë¦¬ê¸°](https://www.acmicpc.net/problem/17822)

<br>

<br>

------

![image-20220422030831613](../../images/boj/boj_image/image-20220422030831613.png)

-------

<br><br>

###### ğŸ’¡ í’€ì´ ê³¼ì •

**ì‹œë®¬ë ˆì´ì…˜ + BFS**

ì›íŒì˜ ì •ë³´ë¥¼ 2ì°¨ì› ë°°ì—´ì— ë‹´ì•„ì„œ ì‹œë®¬ë ˆì´ì…˜ì„ ì§„í–‰í•˜ëŠ” ë¬¸ì œë‹¤

ì¸ì ‘í•œ ë©´ì— ê°™ì€ ìˆ˜ë¥¼ ì°¾ëŠ” ë¶€ë¶„ì´ ìˆì–´ì„œ<span style="color:#2d3748;background-color:#fff5b1"> BFS</span>ë¥¼ ì‚¬ìš©í–ˆë‹¤

ë‹¤ë§Œ, ê°™ì€ ìˆ˜ë¥¼ ì°¾ê³  0ìœ¼ë¡œ ë§Œë“œëŠ” ë¶€ë¶„ì´ ìˆëŠ”ë°, 

<span style="color:#2d3748;background-color:#fff5b1">temp ë°°ì—´</span>ì„ ë§Œë“¤ì–´ì„œ ê²°ê³¼ ê°’ì„ ë‹´ì•„ ë†“ì€ í›„ BFSê°€ ëë‚¬ì„ ë•Œ ê°’ì„ ë°”ê¿”ì¤˜ì•¼í–ˆë‹¤ <span style="color:red">â†’ ë‚´ê°€ ì£¼ë¡œ ì‹¤ìˆ˜ ë§ì´ í•˜ëŠ” ë¶€ë¶„ì´ë‹¤</span>

temp ë°°ì—´ì— ì£¼ì–´ì§„ ì›íŒ ì •ë³´ë¥¼ ë³µì‚¬í•  ë•ŒëŠ” forë¬¸ì„ í†µí•´ ëª¨ë“  ê°’ì„ í™•ì‹¤íˆ ë³µì‚¬í•´ì¤˜ì•¼ í–ˆë‹¤

<br>

-------------

**ë¬¸ì œì˜ íë¦„**ì€ ë‹¤ìŒê³¼ ê°™ë‹¤

1. íšŒì „í•˜ê¸° : rotate
2. ì¸ì ‘í•˜ë©´ì„œ ê°™ì€ ìˆ˜ ì°¾ê¸° : find_adj
3. ì¸ì ‘í•œ ìˆ˜ê°€ ìˆìœ¼ë©´ 0 ì²˜ë¦¬ : find_adj
3. ì¸ì ‘í•œ ìˆ˜ê°€ ì—†ìœ¼ë©´ ë°¸ëŸ°ì‹± : blalance_cal
3. Tì´ˆ ë™ì•ˆ 1,2,3,4 ë°˜ë³µ  

```java
for(int t=1; t<=T;t++) {
	st= new StringTokenizer(br.readLine());
	int x= Integer.parseInt(st.nextToken());
	int dir= Integer.parseInt(st.nextToken());
	int K= Integer.parseInt(st.nextToken());

	//Simulation
	 for(int i=x;i<=N;i=i+x)
		 for(int k=0;k<K;k++)
			 rotate(i,dir);					 
		
	if(!find_adj()) balance_cal();
}
```

<br>

------

##### â–ª íšŒì „í•˜ê¸°

dir==0 ì‹œê³„ ë°©í–¥, dir==1 ë°˜ì‹œê³„ ë°©í–¥

```java
//íšŒì „í•˜ê¸°
static void rotate(int i,int dir) {
	//ì‹œê³„
	if(dir==0) {
		int tmp=circle[i][M];
		for(int j=M-1;j>=1;j--)
			circle[i][j+1]=circle[i][j];
		circle[i][1]=tmp;
	}
	//ë°˜ì‹œê³„
	else if(dir==1) {
		int tmp=circle[i][1];
		for(int j=1;j<M;j++)
			circle[i][j]=circle[i][j+1];
		circle[i][M]=tmp;			
	}
}
```

<br>

-------------------

##### â–ª ì¸ì ‘í•˜ë©´ì„œ ê°™ì€ ìˆ˜ ì°¾ê¸°

íšŒì „íŒ ìˆ«ì ì¤‘ 0ì´ ì•„ë‹Œ ìˆ«ìì— ëŒ€í•´ì„œ ëª¨ë‘ íƒìƒ‰í•œë‹¤

BFS ë„ì¤‘ <span style="color:red">ê°’ì´ ì„ì´ëŠ” ê²ƒì„ ë°©ì§€</span>í•˜ê¸° ìœ„í•´ ì›íŒ ì •ë³´ë¥¼ **temp ë°°ì—´**ì— ë³µì‚¬í•œ í›„ ë‚˜ì¤‘ì— ê°’ì„ ë°”ê¿”ì¤€ë‹¤

**4ë°© íƒìƒ‰**ì„ í†µí•´ ì¸ì ‘í•œ ë©´ì„ íƒìƒ‰í•œë‹¤

ì¸ì ‘í•œ ìˆ˜ë¥¼ ì°¾ê³  ì§€ìš°ëŠ” ê³¼ì •ê¹Œì§€ í•˜ë©´ true, ì¸ì ‘í•œ ìˆ˜ë¥¼ ì°¾ì§€ ëª»í–ˆìœ¼ë©´ falseë¥¼ ë°˜í™˜

```java
//BFSë¡œ ì¸ì ‘í•˜ë©´ì„œ ê°™ì€ ìˆ˜ ì°¾ê¸°
static boolean find_adj() {
	boolean isChange=false;
	Queue<CO> queue = new LinkedList<>();
	for(int i=1;i<=N;i++) {
		for(int j=1;j<=M;j++) {
			if(circle[i][j]>0) 
				queue.offer(new CO(i,j));
		}
	}
		
	int temp[][]=new int[N+1][M+1];
	for(int i=1;i<=N;i++) {
		for(int j=1;j<=M;j++)
			temp[i][j]=circle[i][j];
	}
		
	while(!queue.isEmpty()) {
		CO cur = queue.poll();
		for(int d=0;d<4;d++) {
			int nx=cur.x+dx[d];
			int ny=cur.y+dy[d];
			
			if(nx==M+1) nx=1;
			if(nx==0) nx=M;
			if(nx<1||nx>M||ny<1||ny>N) continue;				
				
			if(circle[ny][nx]==circle[cur.y][cur.x]) {
				temp[ny][nx]=0;
				temp[cur.y][cur.x]=0;
				isChange=true;
			}
		}
	}
	circle=temp;
	return isChange;
}
```

<br>

-----------

##### â–ª íšŒì „íŒ ë°¸ëŸ°ì‹±

ì¸ì ‘í•œ ë¶€ë¶„ì„ ì°¾ì§€ ëª»í–ˆì„ ë•Œ íšŒì „íŒ ìˆ«ì ë°¸ëŸ°ì‹±ì„ í•œë‹¤

íšŒì „íŒ ìˆ«ì í‰ê· ì„ êµ¬í•œ í›„, í‰ê· ë³´ë‹¤ í° ìˆ«ìëŠ” -1, ì‘ì€ ìˆ«ìëŠ” +1ì„ í•´ì¤€ë‹¤

```java
//balancing
static void balance_cal() {
	int sum=0;
	int cnt=0;
	for(int i=1;i<=N;i++) {
		for(int j=1;j<=M;j++) {
			if(circle[i][j]>0) {
				sum+=circle[i][j];
				cnt++;
			}
		}
    }
	double avg=(double)sum/cnt;
		
	for(int i=1;i<=N;i++) {
		for(int j=1;j<=M;j++) {
			if(circle[i][j]<=0) continue;
			if(circle[i][j]>avg) circle[i][j]--;
			else if(circle[i][j]<avg) circle[i][j]++;
		}
	}
}
```

<br>

--------------------

##### â–ª ê²°ê³¼

![image-20220422030129963](../../images/boj/2022-04-19-boj/image-20220422030129963.png)
<br><br>

###### ğŸ“ƒ ì½”ë“œ(java 8)

```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.LinkedList;
import java.util.Queue;
import java.util.StringTokenizer;

public class BOJ_17822_ì›íŒëŒë¦¬ê¸° {
	static int N,M,T;
	static int circle[][];
	static int dx[]= {1,-1,0,0};
	static int dy[]= {0,0,1,-1};
	static int ans;
	
	static class CO{
		int y,x;
		public CO(int y, int x) {
			super();
			this.y = y;
			this.x = x;
		}
	}
	
	public static void main(String[] args) throws IOException {
		BufferedReader br= new BufferedReader(new InputStreamReader(System.in));
		StringTokenizer st = new StringTokenizer(br.readLine());
		N= Integer.parseInt(st.nextToken());
		M= Integer.parseInt(st.nextToken());
		T= Integer.parseInt(st.nextToken());
		
		//íšŒì „íŒ ì •ë³´ ì…ë ¥
		circle= new int[N+1][M+1];
		for(int i=1;i<=N;i++) {
			st = new StringTokenizer(br.readLine());
			for(int j=1;j<=M;j++) 
				circle[i][j]=Integer.parseInt(st.nextToken());
		}

		//íšŒì „ ì¡°ê±´ ì…ë ¥ + ì‹œë®¬ë ˆì´ì…˜
		for(int t=1; t<=T;t++) {
			st= new StringTokenizer(br.readLine());
			int x= Integer.parseInt(st.nextToken());
			int dir= Integer.parseInt(st.nextToken());
			int K= Integer.parseInt(st.nextToken());
	
			//Simulation
			 for(int i=x;i<=N;i=i+x)
				 for(int k=0;k<K;k++)
					 rotate(i,dir);					 
			
			if(!find_adj()) balance_cal();
		}
		
		//ë‹µ êµ¬í•˜ê¸°
		for(int i=1;i<=N;i++) 
			for(int j=1;j<=M;j++) 
				if(circle[i][j]>0) 
					ans+=circle[i][j];
		
		System.out.println(ans);
	}
	
	//íšŒì „í•˜ê¸°
	static void rotate(int i,int dir) {
		//ì‹œê³„
		if(dir==0) {
			int tmp=circle[i][M];
			for(int j=M-1;j>=1;j--)
				circle[i][j+1]=circle[i][j];
			circle[i][1]=tmp;
		}
		//ë°˜ì‹œê³„
		else if(dir==1) {
			int tmp=circle[i][1];
			for(int j=1;j<M;j++)
				circle[i][j]=circle[i][j+1];
			circle[i][M]=tmp;			
		}
	}
	
	//BFSë¡œ ì¸ì ‘í•˜ë©´ì„œ ê°™ì€ ìˆ˜ ì°¾ê¸°
	static boolean find_adj() {
		boolean isChange=false;
		Queue<CO> queue = new LinkedList<>();
		for(int i=1;i<=N;i++) {
			for(int j=1;j<=M;j++) {
				if(circle[i][j]>0) 
					queue.offer(new CO(i,j));
			}
		}
		
		int temp[][]=new int[N+1][M+1];
		for(int i=1;i<=N;i++) {
			for(int j=1;j<=M;j++)
				temp[i][j]=circle[i][j];
		}
		
		while(!queue.isEmpty()) {
			CO cur = queue.poll();
			for(int d=0;d<4;d++) {
				int nx=cur.x+dx[d];
				int ny=cur.y+dy[d];
				
				if(nx==M+1) nx=1;
				if(nx==0) nx=M;
				if(nx<1||nx>M||ny<1||ny>N) continue;				
				
				if(circle[ny][nx]==circle[cur.y][cur.x]) {
					temp[ny][nx]=0;
					temp[cur.y][cur.x]=0;
					isChange=true;
				}
			}
		}
		circle=temp;
		return isChange;
	}
	
	//balancing
	static void balance_cal() {
		int sum=0;
		int cnt=0;
		for(int i=1;i<=N;i++) {
			for(int j=1;j<=M;j++) {
				if(circle[i][j]>0) {
					sum+=circle[i][j];
					cnt++;
				}
			}
		}
		double avg=(double)sum/cnt;
		
		for(int i=1;i<=N;i++) {
			for(int j=1;j<=M;j++) {
				if(circle[i][j]<=0) continue;
				if(circle[i][j]>avg) circle[i][j]--;
				else if(circle[i][j]<avg) circle[i][j]++;
			}
		}
	}
	
}
```

